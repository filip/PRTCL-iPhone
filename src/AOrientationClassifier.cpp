/* *  AOrientationClassifier.cpp *  Which Way Is Up Test * *  Created by Andreas Muller on 10/10/2008. *  Copyright 2008 Nanika. All rights reserved. * */#include "AOrientationClassifier.h"// ------------------------------------------------------------------------------------------------------//AOrientationClassifier::AOrientationClassifier(){	currentDeviceOrientation = DeviceOrientationNormal;	probableDeviceOrientation = DeviceOrientationNormal;		deviceChangedOrientationCallback = NULL;	sentCallbackForThisChange = false;		startupPhaseTicks = 0;	amountTheSameNeeded = 6;			currAmountOfIdenticalReading = 0;	identicalReadingsSoFar = false;			}// ------------------------------------------------------------------------------------------------------//void AOrientationClassifier::newAccelerometerData( float _x, float _y, float _z ){	ADeviceOrientation currReading = classifyOrientation( _x, _y, _z );		//cout << orientationToString( currReading ) << endl;		if( prevReading == currReading )	{		currAmountOfIdenticalReading++;		identicalReadingsSoFar = true;				if( currAmountOfIdenticalReading > amountTheSameNeeded )		{			currentDeviceOrientation = prevReading;						if(!sentCallbackForThisChange)			{				if( deviceChangedOrientationCallback != NULL )				{					deviceChangedOrientationCallback( currentDeviceOrientation );				}								//cout << "*********************************" << endl;				//cout << "Decided on:" << orientationToString( currentDeviceOrientation ) << endl;				//cout << "*********************************" << endl;											sentCallbackForThisChange = true;			}		}	}	else	{		currAmountOfIdenticalReading = 0;		identicalReadingsSoFar = false;			sentCallbackForThisChange = false;	}		prevReading = currReading;}// ------------------------------------------------------------------------------------------------------//ADeviceOrientation AOrientationClassifier::classifyOrientation( float _x, float _y, float _z ){	ADeviceOrientation tmpOrientation = DeviceOrientationNormal;		float xAbs = abs( _x );	float yAbs = abs( _y );	float zAbs = abs( _z );			float asGoodAsZeroCutoff = 0.35f;		if( xAbs < asGoodAsZeroCutoff )	{		// we either normal or upside down		if( _y > 0.0f )		{			tmpOrientation = DeviceOrientationUpsideDown;		}		else		{			tmpOrientation = DeviceOrientationNormal;		}	}	else if ( yAbs < asGoodAsZeroCutoff )	{		// we are on the side		if( _x > 0.0f )		{			tmpOrientation = DeviceOrientationSideButtonLeft;		}		else		{			tmpOrientation = DeviceOrientationSideButtonRight;		}			}		return tmpOrientation;}// ------------------------------------------------------------------------------------------------------//string AOrientationClassifier::orientationToString( ADeviceOrientation _orientation ){	if( _orientation == DeviceOrientationNormal )	{		return "DeviceOrientationNormal";	}	else if( _orientation == DeviceOrientationUpsideDown )	{		return "DeviceOrientationUpsideDown";	}	else if( _orientation == DeviceOrientationSideButtonRight )	{		return "DeviceOrientationSideButtonRight";	}	else if( _orientation == DeviceOrientationSideButtonLeft )	{		return "DeviceOrientationSideButtonLeft";	}	}/* DeviceOrientationNormal, DeviceOrientationUpsideDown, DeviceOrientationSideButtonRight, DeviceOrientationSideButtonLeft	 */